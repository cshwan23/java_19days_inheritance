# java_19days_inheritance
수업복습

1교시 _ 교재 26,27페이지
자식이 부모가 되어달라고 요청
 
(extends 부모)
 
오버로딩
: 한클래스 안에 두개이상 이름이 같은 메소드나 생성자가 있는 경우
이름같고 매개변수 다름
 
오버라이딩
: 부모클래스에 갖고있는 메서드 갖고와서 재정의
 
오버라이딩 규칙
: 실행구문만 바꿔서 재정의함.
: 메소드 이름, 매개변수갯수, 매개변수 자료형, 리턴형 모두 같아야 한다.
접근지정자는 부모와 같거나 부모보다 크면된다.
 
오버라이딩 못하는 경우는 언제인가?
private, final, static이 붙으면 오버라이딩이 안된다.
 
자식은 왜 n개의 부모클래스를 갖지 못하는가?
두 부모클래스 모두 같은 메소드를 갖고있으면
누구부모클래스것을 갖다 쓸지 모른다.
 
@Overriding 
=> annotation
클래스 속성변수 메소드 매개변수 앞에 특정 기능을 부여하는 자바의 표기방법
오버라이딩 규칙을 검사. 
 
 
super 예약어
super = 엄마라는 뜻
 
1.
super. 속성변수 // 자식클래스에서 부모의 속성변수를 호출할 때
 
2.
super. 메소드 
 
3.
super( ) :자식생성자에서 부모님의 생성자를 호출해달라는 의미.
자식생성자 안에 super(부모생성자)가 코딩안해도 숨어있다.
 
 
this( ), super( ) 는 자식생성자 안에서마 나올 수 있는 키워드다.
 
 
자바프로그램을 구성하는 단위. (1.클래스 2.인터페이스)
 
1. 클래스
     1) 일반 클래스 
       : 객체화가 가능
     2) 추상 클래스
(본사인데 피자도 만듦)
(반은 인터페이스 특징(바디없는메서드)/반은 일반클래스 특징 갖고있다)
(바디없는 메소드 / 
       : 바디가 없는 메소드를 한개이상 소유하거나
       : 조상이 바디가 없는 메소드 하나이상 있거나 한 클래스
       : 객체화가 안된다
         (왜 만들었나 구현이나 상속받는 클래스가 풍요러워지게 한다.)
       : 후손 클래스가 혜택을 받음.
2. 인터페이스
(본사)
       : 바디없는 메소드로 이루어져 있다.
       : 객체화가 안된다
         (왜 만들었나 구현받는 클래스가 이득이 생기고  풍요러워지게 한다.)
 
 
스프링프레임워크 단점
: 클래스 만들기 전 인터페이스 만들어야 된다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
2교시
 
 
class A {
    void a1() {~}
    void a2() {~}
}
class B extends A {
    void b1() {~}
    void a2() {~}
}
class C extends A {
    void c1() {~}
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡ
B b = new B();
b.b1();  //o
b.a1();  //o
ㅡㅡㅡㅡㅡㅡㅡㅡ
A b = new B();
b.b1();  //x
b.a1();  //o
b.a2();  //o
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3교시_어렵다 다시보기
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

아래 질문에 대답할 수 있는 사람

대답율 0.5명/10명중

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

ㅡㅡㅡㅡㅡㅡ    ㅡㅡㅡㅡㅡㅡ    ㅡㅡㅡㅡㅡㅡ
   A클래스            B클래스            C클래스
ㅡㅡㅡㅡㅡㅡ   ㅡㅡㅡㅡㅡㅡ     ㅡㅡㅡㅡㅡㅡ
  a1( ) {~~}        b1( ) {~~}        c1( ) {~~}
ㅡㅡㅡㅡㅡㅡ   ㅡㅡㅡㅡㅡㅡ     ㅡㅡㅡㅡㅡㅡ
 
세명이 어느놈이 객체화 될지 모른다.
만약 셋중에 1놈이 객체화가 된다면.. 이라고 조건문을 만든다.
 
만약 셋이 아니라 백명 천명 이된다면 조건문이 비대해진다. 조건문이 늘어난다.
이건 프로그래밍이 아니다. 코딩이 아니다. 
 
n개의 중 하나가 객체화가 된다면 
 
어떤 기법을 쓰냐하면?
.
.
.
.
                            ㅡㅡㅡㅡㅡㅡㅡㅡ
                                  Z클래스
                            ㅡㅡㅡㅡㅡㅡㅡㅡ
                             z1( ) {실행구문1}
                            ㅡㅡㅡㅡㅡㅡㅡㅡ
           |                           |                              |
           |                           |                              |
           |                           |                              |
ㅡㅡㅡㅡㅡㅡ           ㅡㅡㅡㅡㅡㅡ           ㅡㅡㅡㅡㅡㅡ
   A클래스                  B클래스                  C클래스
ㅡㅡㅡㅡㅡㅡ          ㅡㅡㅡㅡㅡㅡ           ㅡㅡㅡㅡㅡㅡ
  a1( ) {~~}               b1( ) {~~}               c1( ) {~~}
z1( ){실행구문2}    z1( ){실행구문3}     z1( ){실행구문4}
ㅡㅡㅡㅡㅡㅡ          ㅡㅡㅡㅡㅡㅡ           ㅡㅡㅡㅡㅡㅡ
 
a1,b1,c1은 고유메서드다.
z1을 오버라이딩 한거다
 
> A클래스가 객체화 된다면?
A a = new A ();
a.a1()
 
> B클래스가 객체화 된다면?
B b = new A ();
b.b1()
 
> C클래스가 객체화 된다면?
C c = new A ();
c.c1()
 
조건문이 너무 늘어난다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
....그래서 이렇게 한다.
a클래스를 객체화하면 실행구문 2를 실행하는게 목적이다.
b클래스를 객체화하면 실행구문 3를 실행하는게 목적이다.
c클래스를 객체화하면 실행구문 4를 실행하는게 목적이다.
 
Z a = new ? ();   // 물음표가 a가들어가던 b가 들어가던 c가들어가던 
a.z1(); => 에러 안난다  
a.a1( ); ->에러난다 ?물음표자리에 a가 들어가면 에러가 나지않지만 다른 놈이 들어오면 에러가난다.
a.b1( );  error
a.c1( );  error
?자리에 뭐가들어갈지 모르는데 고유멤버 호출을 막아논거다. 
a클래스 b클래스 c누가 객체화 될지 모른다.
고유멤버를 호출하게 만들어? 말이 안된다.
 
Z a = new ? (); 
a.z1();
단 두줄로 저 세개 클래스를 실행하게 만든다.(이 두줄 이해하고 넘어가자)
 
<1> z1실행구문 2 를 실행시키고 싶다
Z a = new A ();   
a.z1( ); 
=> 물음표자리에 a를 쓰면 된다.
<2> z1실행구문 3 를 실행시키고 싶다
Z a = new B ();   
a.z1( ); 
=> 물음표자리에 b를 쓰면 된다.
<3> z1실행구문 4 를 실행시키고 싶다
Z a = new C ();   
a.z1( ); 
=> 물음표자리에 c를 쓰면 된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

 
4교시(코딩 녹음 들으며 다시 복습무조건)
 
인터페이스 왜 만들었냐?
인터페이스 구현받은 클래스들이 혜택이 크다.
자기를 희생
자기가 타겟이 아니라 얘를 구현받은 클래스가 타겟이 된다.
 
인터페이스 만들때 
속성변수에 public을 안붙이면, 디폴트인데 에러가 날까?
 
인터페이스는 원래 규정자체가
내가 안넣으면 넣어준다 없어도 넣어준다.
(public , final, static ) + 속성변수  
(public, abstract) + 메소드
생략해도 된다.. 원래 다 들어가야하기때문에 자바가 알아서 넣는다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
<자바 1차 시험문제>checkcardexe 파일. 코딩
package com.eee.erp;
 
public class ChekCardExe {
 
public static void main(String[] args) {
// TODO Auto-generated method stub
 
}
 
}
 
 
// 
 
 
 
